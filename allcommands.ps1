### DO NOT EDIT THIS FILE DIRECTLY ###

#.ExternalHelp HelpOut-Help.xml
function Get-MAML{[CmdletBinding(DefaultParameterSetName='CommandInfo')][OutputType([string],[xml])][Alias('ConvertTo-MAML')]param([Parameter(ParameterSetName='ByName',Position=0,ValueFromPipelineByPropertyName=$true)][string[]]$Name,[Parameter(ParameterSetName='ByModule',ValueFromPipelineByPropertyName=$true)][string[]]$Module,[Parameter(Mandatory=$true,ParameterSetName='FromCommandInfo', ValueFromPipeline=$true)][Management.Automation.CommandInfo[]]$CommandInfo,[switch]$Compact,[switch]$XML,[Alias('Unversioned')][switch]$NoVersion)begin{$allCommands=[Collections.ArrayList]::new();$typeAccelerators=[PSOBject].Assembly.GetType('System.Management.Automation.TypeAccelerators')::Get;$GetTypeName={param([Type]$t)if(-not $typeAccelerators-and$typeAccelerators.GetEnumerator){return $t.Fullname};foreach($_ in $typeAccelerators.GetEnumerator()){if($_.Value-eq$t){return $_.Key.Substring(0,1).ToUpper() + $_.Key.Substring(1)}};return $t.Fullname};$WriteType={param($t)$typename=$t.type[0].name;$descriptionLines=$null;if($in.description){$descriptionLines=$in.Description[0].text-split"`n|`r`n"-ne''}else{$typename, $descriptionLines=$t.type[0].Name-split"`n|`r`n"-ne''};$typename=[Security.SecurityElement]::Escape("$typename".Trim());"<dev:type><maml:name>$typename</maml:name><maml:uri/><maml:description /></dev:type>";if($descriptionLines){'<maml:description>';foreach($line in $descriptionLines){$esc=[Security.SecurityElement]::Escape($line);"<maml:para>$esc</maml:para>"};'</maml:description>'}};$writeCommandDetails={$Version="<dev:version>$(if ($cmdInfo.Version) { $cmdInfo.Version.ToString() })</dev:version>";"<command:details>
                <command:name>$([Security.SecurityElement]::Escape($cmdInfo.Name))</command:name>
                <command:noun>$noun</command:noun>
                <command:verb>$verb</command:verb>
                <maml:description>
                    <maml:para>$([Security.SecurityElement]::Escape($commandHelp.Synopsis))</maml:para>
                </maml:description>
                $(if (-not $NoVersion) { $Version})
            </command:details>
            <maml:description>
                $(
                foreach ($line in @($commandHelp.Description)[0].text -split "`n|`r`n") {
                    if (-not $line) { continue }
                    "<maml:para>$([Security.SecurityElement]::Escape($Line))</maml:para>"
                    }
                )                
            </maml:description>
            "};$WriteParameter={$position=if($param.Position-ge0){$param.Position}else{"named"};$fromPipeline=if($param.ValueFromPipeline){"True (ByValue)"}elseif($param.ValueFromPipelineByPropertyName){"True (ByPropertyName)"}else{"False"};$isRequired=if($param.IsMandatory){"true"}else{"false"};$paramHelp=foreach($_ in $commandHelp.parameters.parameter){if($_.Name-eq$param.Name){$_;break}};$paramTypeName=& $GetTypeName $param.ParameterType;"<command:parameter required='$isRequired' position='$position' pipelineInput='$fromPipeline' aliases='' variableLength='true' globbing='false'>";"<maml:name>$($param.Name)</maml:name>";'<maml:description>';foreach($d in $paramHelp.Description){"<maml:para>$([Security.SecurityElement]::Escape($d.Text))</maml:para>"};'</maml:description>';"<command:parameterValue required='$isRequired' variableLength='true'>$paramTypeName</command:parameterValue>";"<dev:type><maml:name>$paramTypeName</maml:name><maml:uri /></dev:type>";'<dev:defaultValue></dev:defaultValue>';'</command:parameter>'};$WriteCommandParameters={'<command:parameters>';foreach($param in ($cmdMd.Parameters.Values|Sort-Object Name)){& $WriteParameter};'</command:parameters>'};$WriteExamples={if(-not $commandHelp.Examples.example){return};"<command:examples>";foreach($ex in $commandHelp.Examples.Example){'<command:example>';'<maml:title>';$ex.Title;'</maml:title>';'<maml:introduction>';foreach($i in $ex.Introduction){'<maml:para>';[Security.SecurityElement]::Escape($i.Text);'</maml:para>'};'</maml:introduction>';'<dev:code>';[Security.SecurityElement]::Escape($ex.Code);'</dev:code>';'<dev:remarks>';foreach($i in $ex.Remarks){if(-not $i-or-not $i.Text.Trim()){continue};'<maml:para>';[Security.SecurityElement]::Escape($i.Text);'</maml:para>'};'</dev:remarks>';'</command:example>'};'</command:examples>'};$WriteInputs={if(-not $commandHelp.inputTypes){return};'<command:inputTypes>';foreach($in in $commandHelp.inputTypes[0].inputType){'<command:inputType>';& $WriteType $in;'</command:inputType>'};'</command:inputTypes>'};$WriteOutputs={if(-not $commandHelp.returnValues){return};'<command:returnValues>';foreach($rt in $commandHelp.returnValues[0].returnValue){'<command:returnValue>';& $WriteType $rt;'</command:returnValue>'};'</command:returnValues>'};$WriteNotes={if(-not $commandHelp.alertSet){return};"<maml:alertSet><maml:title></maml:title>";foreach($note in $commandHelp.alertSet[0].alert){"<maml:alert><maml:para>";$([Security.SecurityElement]::Escape($note.Text));"</maml:para></maml:alert>"};"</maml:alertSet>"};$WriteSyntax={if(-not $cmdInfo.ParameterSets){return};"<command:syntax>";foreach($syn in $cmdInfo.ParameterSets){"<command:syntaxItem><maml:name>$($cmdInfo.Name)</maml:name>";foreach($param in $syn.Parameters){if(-not $cmdMd.Parameters.ContainsKey($param.Name)){continue};& $WriteParameter};"</command:syntaxItem>"};"</command:syntax>"};$WriteLinks={if(-not $commandHelp.relatedLinks.navigationLink){return};'<maml:relatedLinks>';foreach($l in $commandHelp.relatedLinks.navigationLink){$linkText, $LinkUrl="$($l.linkText)".Trim(),"$($l.Uri)".Trim();'<maml:navigationLink>';"<maml:linkText>$linkText</maml:linkText>";"<maml:uri>$LinkUrl</maml:uri>";'</maml:navigationLink>'};'</maml:relatedLinks>'};$WriteMaml=$writeCommandDetails,$writeSyntax,$WriteCommandParameters,$WriteInputs,$writeOutputs,$writeNotes,$WriteExamples,$writeLinks}process{if($PSCmdlet.ParameterSetName-eq'ByName'){$CommandInfo=@(foreach($n in $name){$ExecutionContext.InvokeCommand.GetCommands($N,'Function,Cmdlet', $true)})};if($PSCmdlet.ParameterSetName-eq'ByModule'){$CommandInfo=@(foreach($m in $module){(Get-Module -Name $m).ExportedCommands.Values})};$filteredCmds=@(foreach($ci in $CommandInfo){if($ci-is[Management.Automation.AliasInfo]-or$ci-is[Management.Automation.ApplicationInfo]){continue};$ci});if($filteredCmds){$null=$allCommands.AddRange($filteredCmds)}}end{$c, $t, $id, $maml=0,$allCommands.Count,[Random]::new().Next(),[Text.StringBuilder]::new('<helpItems schema="maml">');foreach($cmdInfo in $allCommands){$commandHelp=$null;$c++;$p=$c*100/$t;Write-Progress 'Converting to MAML' "$cmdInfo [$c of $t]" -PercentComplete $p -Id $id;$commandHelp=$cmdInfo|Get-Help;$cmdMd=[Management.Automation.CommandMetaData]$cmdInfo;if(-not $commandHelp-or$commandHelp-is[string]){Write-Error "$cmdInfo Must have a help topic to convert to MAML";return};$verb, $noun=$cmdInfo.Name-split"-";$mamlCommand="<command:command 
                    xmlns:maml='http://schemas.microsoft.com/maml/2004/10' 
                    xmlns:command='http://schemas.microsoft.com/maml/dev/command/2004/10' 
                    xmlns:dev='http://schemas.microsoft.com/maml/dev/2004/10'>
                    $(foreach ($_ in $WriteMaml) { & $_ })
                </command:command>";$null=$maml.AppendLine($mamlCommand)};Write-Progress "Exporting Maml" " " -Completed -Id $id;$null=$maml.Append("</helpItems>");$mamlAsXml=[xml]"$maml";if(-not $mamlAsXml){return};if($XML){return $mamlAsXml};$strWrite=[IO.StringWriter]::new();$mamlAsXml.PreserveWhitespace=$Compact;$mamlAsXml.Save($strWrite);"$strWrite".Replace('<?xml version="1.0" encoding="utf-16"?>','<?xml version="1.0" encoding="utf-8"?>');$strWrite.Close();$strWrite.Dispose()}} 
#.ExternalHelp HelpOut-Help.xml
function Get-MarkdownHelp{[Reflection.AssemblyMetadata("HelpOut.TellStory", $true)][Reflection.AssemblyMetadata("HelpOut.Story.Process", "For each Command")][OutputType('PowerShell.Markdown.Help')]param([Parameter(Position=0, ValueFromPipelineByPropertyName)][ValidateNotNullOrEmpty()][string]$Name,[switch]$Wiki,[Alias('GitHubPageRoot')][string]$GitHubDocRoot,[Parameter(ValueFromPipelineByPropertyName)][string]$Rename,[Parameter(ValueFromPipelineByPropertyName)][string[]]$SectionOrder,[Parameter(ValueFromPipelineByPropertyName)][switch]$NoValidValueEnumeration,[Parameter(ValueFromPipelineByPropertyName)][Alias('IncludeFrontMatter', 'IncludeHeader')][switch]$IncludeYamlHeader,[ValidateSet('Command','Help','Metadata')][Alias('YamlHeaderInfoType')][string[]]$YamlHeaderInformationType,[PSObject]$FormatAttribute)process{$myParams=@{}+$PSBoundParameters;$getHelp=@{name=$Name};$gotHelp=Get-Help @getHelp;if(-not $gotHelp){Write-Error "Could not get help for $name";return};$gotHelp|& {process{$in=$_;if($in-is[string]){$in}else{$helpObj=$_;$helpObj.pstypenames.insert(0,'PowerShell.Markdown.Help');$IsHelpAboutAlias=$helpObj.Name-ne$gotHelp.Name;$helpObj|Add-Member NoteProperty IsAlias $IsHelpAboutAlias -Force;if($IsHelpAboutAlias){$aliasCommand=$ExecutionContext.SessionState.InvokeCommand.GetCommand($gotHelp.Name, 'Alias');$helpObj|Add-Member NoteProperty AliasCommand $aliasCommand -Force};if($Rename){$helpObj|Add-Member NoteProperty Rename $Rename -Force}elseif($IsHelpAboutAlias){$helpObj|Add-Member NoteProperty Rename $gotHelp.Name -Force};if($SectionOrder){$helpObj|Add-Member NoteProperty SectionOrder $SectionOrder -Force};$helpObj|Add-Member NoteProperty WikiLink ($Wiki -as [bool]) -Force;if($myParams.ContainsKey("GitHubDocRoot")){$helpObj|Add-Member NoteProperty DocLink $GitHubDocRoot -Force};$helpObj|Add-Member NoteProperty NoValidValueEnumeration $NoValidValueEnumeration -Force;$helpObj|Add-Member NoteProperty IncludeYamlHeader $IncludeYamlHeader -Force;$helpObj|Add-Member NoteProperty YamlHeaderInformationType $YamlHeaderInformationType -Force;if($FormatAttribute){$helpObj|Add-Member NoteProperty FormatAttribute $FormatAttribute -Force};$helpObj}}}}} 
#.ExternalHelp HelpOut-Help.xml
function Get-ScriptReference{[CmdletBinding(DefaultParameterSetName='FilePath')]param([Parameter(Mandatory=$true,Position=0,ParameterSetName='FilePath',ValueFromPipelineByPropertyName=$true)][Alias('Fullname')][string[]]$FilePath,[Parameter(Mandatory=$true,Position=0,ParameterSetName='ScriptBlock',ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true)][Alias('Definition')][ScriptBlock[]]$ScriptBlock,[switch]$Recurse)begin{$allFiles=[Collections.ArrayList]::new();$LookedUpCommands=@{}}process{if($PSCmdlet.ParameterSetName-eq'FilePath'){$allFiles.AddRange($FilePath);return};$scriptBlockQueue=[Collections.Generic.Queue[ScriptBlock]]::new($ScriptBlock);$resolvedCmds=@{};$alreadyChecked=[Collections.Generic.List[ScriptBlock]]::new();$CurrentCommand='.';. {$alreadyChecked=[Collections.ArrayList]::new();do{$scriptBlock=$scriptBlockQueue.Dequeue();if($alreadyChecked-contains$scriptBlock){continue};$null=$alreadyChecked.Add($ScriptBlock);$foundRefs=$Scriptblock.Ast.FindAll({
                    param($ast) 
                    $ast -is [Management.Automation.Language.CommandAst] -or 
                    $ast -is [Management.Automation.Language.TypeConstraintAst] -or 
                    $ast -is [Management.Automation.Language.TypeExpressionAst]
                }, $true);$cmdRefs=[Collections.ArrayList]::new();$cmdStatements=[Collections.ArrayList]::new();$typeRefs=[Collections.ArrayList]::new();foreach($ref in $foundRefs){if($ref-is[Management.Automation.Language.CommandAst]){$null=$cmdStatements.Add($ref);if(-not $ref.CommandElements){continue};$theCmd=$ref.CommandElements[0];if($theCmd.Value){if(-not $LookedUpCommands[$theCmd.Value]){$LookedUpCommands[$thecmd.Value]=$ExecutionContext.InvokeCommand.GetCommand($theCmd.Value, 'Cmdlet, Function, Alias')};if($cmdRefs-notcontains$LookedUpCommands[$theCmd.Value]){$null=$cmdRefs.Add($LookedUpCommands[$thecmd.Value])}}else{}}elseif($ref.TypeName){$refType=$ref.TypeName.Fullname-as[type];if($typeRefs-notcontains$refType){$null=$typeRefs.Add($refType)}}};[PSCustomObject][Ordered]@{Commands=$cmdRefs.ToArray();Statements=$cmdStatements.ToArray();Types=$typeRefs.ToArray()};if($Recurse){$uniqueCmdRefs|& {process{if($resolvedCmds.ContainsKey($_.Name)){return};$nextScriptBlock=$_.ScriptBlock;if(-not $nextScriptBlock-and$_.ResolvedCommand.ScriptBlock){$nextScriptBlock=$_.ResolvedCommand.ScriptBlock};if($nextScriptBlock){$scriptBlockQueue.Enqueue($nextScriptBlock);$resolvedCmds[$_.Name]=$true}}}}}while($ScriptBlockQueue.Count)}|& {begin{$refTable=@{}}process{if(-not $Recurse){return $_}}}}end{$myParams=@{}+$PSBoundParameters;if(-not $allFiles.Count){return};$c, $t, $id=0,$allFiles.Count,[Random]::new().Next();foreach($file in $allFiles){$c++;$resolvedFile=try{$ExecutionContext.SessionState.Path.GetResolvedPSPathFromPSPath($file)}catch{$null};if(-not $resolvedFile){continue};$resolvedFile=[IO.FileInfo]"$resolvedFile";if(-not $resolvedFile.Name){continue};if(-not $resolvedFile.Length){continue};if('.ps1','.psm1'-notcontains$resolvedFile.Extension){continue};$p=$c*100/$t;$text=[IO.File]::ReadAllText($resolvedFile.FullName);$scriptBlock=[ScriptBlock]::Create($text);Write-Progress "Getting References" " $($resolvedFile.Name) " -PercentComplete $p -Id $id;if(-not $scriptBlock){continue};Get-ScriptReference -ScriptBlock $scriptBlock|& {process{$_.psobject.properties.add([Management.Automation.PSNoteProperty]::new('FileName',$resolvedFile.Name));$_.psobject.properties.add([Management.Automation.PSNoteProperty]::new('FilePath',$resolvedFile.Fullname));$_.pstypenames.add('HelpOut.Script.Reference');$_}};Write-Progress "Getting References" " " -Completed -Id $id}}} 
#.ExternalHelp HelpOut-Help.xml
function Get-ScriptStory{[CmdletBinding(DefaultParameterSetName='ScriptBlock')]param([Parameter(Mandatory=$true,Position=0,ValueFromPipeline=$true,ParameterSetName='ScriptBlock')][ScriptBlock]$ScriptBlock,[Parameter(Mandatory=$true,Position=0,ValueFromPipeline=$true,ValueFromPipelineByPropertyName=$true,ParameterSetName='ScriptText')][Alias('ScriptContents', 'Definition')][string]$Text,[Collections.IDictionary]$RegionName,[int]$HeadingSize)process
#.ExternalHelp HelpOut-Help.xml
{function foo{};if($PSCmdlet.ParameterSetName-eq'ScriptText'){$ScriptBlock=[ScriptBlock]::Create($Text)};$tokens=@([Management.Automation.PSParser]::Tokenize("$ScriptBlock", [ref]$null));$regionStack=[Collections.Stack]::new();$sb=[text.stringbuilder]::new();$blockDepth=0;for($i =0;$i -lt $tokens.Length;$i++){if($tokens[$i].Type-eq'GroupStart'){$blockDepth++};if($tokens[$i].Type-eq'GroupEnd'){$blockDepth--};if($tokens[$i].Type-eq'keyword'-and'begin','process','end'-contains$tokens[$i].content-and$blockDepth-le1){if($regionStack.Count){$null=$regionStack.Pop()};$null=$regionStack.Push($tokens[$i].Content);$keywordHeader=[Environment]::NewLine+('#'*([Math]::Min(6, $regionStack.Count + $HeadingSize - 1)))+' '+$(if($RegionName[$tokens[$i].Content]){$RegionName[$tokens[$i].Content]}else{$tokens[$i].Content})+[Environment]::NewLine;$null=$sb.Append($keywordHeader);continue};if($tokens[$i].Type-eq'keyword'-and'param','function'-contains$tokens[$i].Content){$j=$i+1;while($tokens[$j].Type -ne 'GroupStart'){$j++};$skipGroupCount=1;if($tokens[$j].Content-eq'('-and$tokens[$i].Content-eq'function'){$skipGroupCount=2};foreach($n in 1..$skipGroupCount){while($tokens[$j].Type -ne 'GroupStart'){$j++};$depth=0;do{if($tokens[$j].Type-eq'GroupStart'){$depth++};if($tokens[$j].Type-eq'GroupEnd'){$depth--};$j++}while($depth -and $tokens[$j])};$i=$j};if($i-ge2-and$tokens[$i].Type-eq'Newline'-and$tokens[$i -1].Type-eq'Newline'){if($i-ge3-and$tokens[$i - 2].Type-eq'GroupEnd'){continue};$null=$sb.Append([Environment]::NewLine * 2)};if($tokens[$i].Type-ne'Comment'){continue};$Comment=$tokens[$i].Content.Trim([Environment]::NewLine).Trim();if($Comment.StartsWith('<')){$trimmedComment=$comment.Trim('<#').Trim([Environment]::NewLine).Trim();if('?','.','{','-','|'-contains$trimmedComment[0]){continue};$Comment=$Comment.Trim().Trim("><#").Trim([Environment]::NewLine)};if($Comment.Trim()-match'#(?<IsEnd>end){0,1}region(?<RegionName>.{1,})'){$thisRegionName=$Matches.RegionName.Trim();if($Matches.IsEnd){$null=$regionStack.Pop()}else{$null=$regionStack.Push($thisRegionName);$regionContent=[Environment]::NewLine+('#'*([Math]::Min(6, $regionStack.Count + $HeadingSize - 1)))+' '+$(if($RegionName[$thisRegionName]){$RegionName[$thisRegionName]}else{$Matches.RegionName.Trim()})+[Environment]::NewLine;$null=$sb.Append($regionContent)};continue};$newStory=$Comment.TrimStart('#').Trim();if($sb.Length){$null=if($sb[-1]-eq'.'){$sb.Append('  ')}else{$sb.Append(' ')}};$shouldHaveNewline=$newStory.StartsWith('*')-or$newStory.StartsWith('-')-or($lastStory-and($lastStory.StartsWith('*')-or$lastStory.StartsWith('-')));if($shouldHaveNewline){$null=$sb.Append([Environment]::NewLine)};$null=$sb.Append($newStory)};"$sb"}} 
#.ExternalHelp HelpOut-Help.xml
function Install-MAML{[OutputType([Nullable], [IO.FileInfo])]param([Parameter(Mandatory,Position=0,ParameterSetName='Module',ValueFromPipelineByPropertyName)][string[]]$Module,[Parameter(ValueFromPipelineByPropertyName)][switch]$NoRefresh,[Parameter(ValueFromPipelineByPropertyName)][switch]$Compact,[Parameter(Position=1,ValueFromPipelineByPropertyName)][string]$ScriptName,[Parameter(ValueFromPipelineByPropertyName)][string[]]$FunctionRoot,[Parameter(ValueFromPipelineByPropertyName)][switch]$NoRecurse,[Parameter(Position=2,ValueFromPipelineByPropertyName)][ValidateNotNull()][Text.Encoding]$Encoding,[Parameter(ValueFromPipelineByPropertyName)][string[]]$Exclude,[Parameter(ValueFromPipelineByPropertyName)][Alias('Unversioned')][switch]$NoVersion,[Parameter(ValueFromPipelineByPropertyName)][Globalization.CultureInfo]$Culture,[Parameter(ValueFromPipelineByPropertyName)][Alias('NoBlockComments','NoBlockComment','NoComments')][switch]$NoComment,[Parameter(ValueFromPipelineByPropertyName)][switch]$PassThru,[Parameter(ValueFromPipelineByPropertyName)][switch]$Minify,[Parameter(ValueFromPipelineByPropertyName)][string]$MinifierSource)process{if($ScriptName-notlike'*.ps1'){$ScriptName+='.ps1'};$Exclude+=$ScriptName;if(-not $Culture){$Culture=[Globalization.CultureInfo]::CurrentUICulture};foreach($m in $Module){$theModule=Get-Module $m;if(-not $theModule){continue};$theModuleRoot=$theModule|Split-Path;if($PSBoundParameters.FunctionRoot){$functionRoot=foreach($f in $FunctionRoot){if([IO.File]::Exists($F)){$f}else{Join-Path $theModuleRoot $f}}}else{$FunctionRoot="$theModuleRoot"};$fileList=@(foreach($f in $FunctionRoot){Get-ChildItem -Path $f -Recurse:$(-not $Recurse) -Filter *.ps1|& {process{if($_.Name-notlike'*-*'-or$_.Name-like'*.*.*'){return};foreach($ex in $Exclude){if($_.Name-like$ex){return}};return $_}}});if(-not $NoRefresh){$saveMamlCmd=if($MyInvocation.MyCommand.ScriptBlock.Module){$MyInvocation.MyCommand.ScriptBlock.Module.ExportedCommands['Save-MAML']}else{$ExecutionContext.SessionState.InvokeCommand.GetCommand('Save-MAML', 'Function')};$saveMamlSplat=@{}+$PSBoundParameters;foreach($k in @($saveMamlSplat.Keys)){if(-not $saveMamlCmd.Parameters.ContainsKey($k)){$saveMamlSplat.Remove($k)}};$saveMamlSplat.Module=$m;Save-MAML @saveMamlSplat};$regex=[Regex]::new('
                (?<![-\s\#]{1,}) # not preceeded by a -, or whitespace, or a comment
                function # function keyword
                \s{1,1} # a single space or tab
                (?<Name>[^\-]{1,1}\S+) # any non-whitespace, starting with a non-dash
                \s{0,} # optional whitespace
                [\(\{] # opening parenthesis or brackets
', 'MultiLine,IgnoreCase,IgnorePatternWhitespace', '00:00:05');$compressScriptBlockCmd=$null;if($Minify){$compressScriptBlockCmd=$($executionContext.SessionState.InvokeCommand.GetCommands("Compress-ScriptBlock*", "Function", $true));if(-not $compressScriptBlockCmd){if($MinifierSource-eq'Gallery'){$installedPSMinifier=Install-Module -Name PSMinifier -Scope CurrentUser -Force;if($?){Import-Module PSMinifier -Global}}else{if($MinifierSource-eq'GitHub'-or-not $MinifierSource){$MinifierSource="https://raw.githubusercontent.com/StartAutomating/PSMinifier/master/Compress-ScriptBlock.min.ps1"};$downloadedMinifier=Invoke-RestMethod -Uri $MinifierSource;. ([scriptblock]::Create($downloadedMinifier))};$compressScriptBlockCmd=$($executionContext.SessionState.InvokeCommand.GetCommands("Compress-ScriptBlock*", "Function", $true))}};$newFileContent=foreach($f in $fileList){$fCmd=$ExecutionContext.SessionState.InvokeCommand.GetCommand($f.FullName, 'ExternalScript');$fileContent=if($Minify-and$compressScriptBlockCmd){& $compressScriptBlockCmd $fCmd.ScriptBlock}else{"$($fCmd.ScriptBlock)"};$start=0;do{$matched=$regex.Match($fileContent,$start);if($matched.Success){$insert=([Environment]::NewLine+"#.ExternalHelp $M-Help.xml"+[Environment]::NewLine);$fileContent=if($matched.Index){$fileContent.Insert($matched.Index - 1, $insert)}else{$insert+$fileContent};$start+=$matched.Index+$matched.Length;$start+=$insert.Length}}while($start -le $filecontent.Length -and $matched.Success);if($NoComment){try{[Regex]::new('\<\#[\S\s]+?\#\>', 'Multiline,IgnoreCase,IgnorePatternWhitespace', [Timespan]'00:00:05').Replace($fileContent, '')}catch{$fileContent}}else{$fileContent}};$combinedCommandsPath=Join-Path $theModuleRoot $ScriptName;"### DO NOT EDIT THIS FILE DIRECTLY ###"|Set-Content -Path $combinedCommandsPath -Encoding $Encoding.HeaderName.Replace('-','');[IO.File]::AppendAllText($combinedCommandsPath, $newFileContent, $Encoding);if($PassThru){Get-Item -Path $combinedCommandsPath}}}} 
#.ExternalHelp HelpOut-Help.xml
function Measure-Help{[CmdletBinding(DefaultParameterSetName='FilePath')]param([Parameter(Mandatory,ValueFromPipelineByPropertyName,Position=0,ParameterSetName='FilePath')][Alias('Fullname')][string]$FilePath,[Parameter(Mandatory,ParameterSetName='ScriptBlock',ValueFromPipelineByPropertyName)][ScriptBlock]$ScriptBlock,[Parameter(ParameterSetName='ScriptBlock',ValueFromPipelineByPropertyName)][string]$Name)begin{$fileList=New-Object Collections.ArrayList;$ScriptBlockList=New-Object Collections.ArrayList;$NameList=New-Object Collections.ArrayList;filter OutputDocRatio{process{$scriptText=$_;$scriptToken=[Management.Automation.PSParser]::Tokenize($scriptText, [ref]$null);$commentLength=0;$otherLength=0;$blockCommentLength=0;$inlineCommentLength=0;$blockComments=@();$inlineComments=@();$totalLength=0;foreach($token in $ScriptToken){$totalLength+=$token.Length;if($token.Type-eq'Comment'){if($token.Content.StartsWith('<#')){$blockComments+=$token;$blockCommentLength+=$token.Length}else{$inlineComments+=$token;$inlineCommentLength+=$token.Length};$commentLength+=$token.Length}else{$otherLength+=$token.Length}};$percent=$commentLength*100/$totalLength;@{CommentLength=$commentLength;TokenLength=$otherLength;CommentPercent=$percent;BlockComments=$blockComments;BlockCommentLength=$blockCommentLength;InlineComments=$inlineComments;InlineCommentLength=$inlineCommentLength}}}}process{if($PSCmdlet.ParameterSetName-eq'FilePath'){$fileList.AddRange(@($FilePath))}elseif($PSCmdlet.ParameterSetName-eq'ScriptBlock'){$null=$ScriptBlockList.Add($ScriptBlock);$null=$NameList.Add($Name)}}end{if($ScriptBlockList.Count){$scriptBlockIndex=0;foreach($sb in $ScriptBlockList){[PSCustomObject]([Ordered]@{PSTypeName="Documentation.Percentage";Name=$NameList[$scriptBlockIndex];ScriptBlock=$sb}+($sb|OutputDocRatio));$scriptBlockIndex++}};if($fileList.Count){foreach($f in $fileList){$RF=$ExecutionContext.SessionState.Path.GetResolvedPSPathFromPSPath($F);if(-not $rf){continue};$fileItem=Get-Item -LiteralPath $RF;$sb=$null;$sb=try{[ScriptBlock]::Create([IO.File]::ReadAllText($RF))}catch{$null};if($sb){[PSCustomObject]([Ordered]@{PSTypeName="File.Documentation.Percentage";Name=$fileItem.Name;FilePath="$rf";ScriptBlock=$sb}+($sb|OutputDocRatio))}}}}} 
#.ExternalHelp HelpOut-Help.xml
function Save-MAML{[CmdletBinding(DefaultParameterSetName='CommandInfo',SupportsShouldProcess=$true)][OutputType([Nullable], [IO.FileInfo])]param([Parameter(ParameterSetName='ByModule',ValueFromPipelineByPropertyName=$true)][string[]]$Module,[Parameter(ValueFromPipelineByPropertyName=$true)][switch]$Compact,[Parameter(ValueFromPipelineByPropertyName=$true)][Globalization.CultureInfo]$Culture,[Alias('Unversioned')][switch]$NoVersion,[switch]$PassThru)begin{$getMAML=if($MyInvocation.MyCommand.ScriptBlock.Module){$MyInvocation.MyCommand.ScriptBlock.Module.ExportedCommands['Get-MAML']}else{$ExecutionContext.SessionState.InvokeCommand.GetCommand('Get-MAML', 'Function')}}process{if(-not $getMAML){Write-Error "Could not Find Get-MAML" -Category ObjectNotFound -ErrorId Get-MAML.NotFound;return};$c, $t, $id=0,$Module.Length,[Random]::new().Next();$splat=@{}+$PSBoundParameters;foreach($k in @($splat.Keys)){if(-not $getMAML.Parameters.ContainsKey($k)){$splat.Remove($k)}};if(-not $Culture){$Culture=[Globalization.CultureInfo]::CurrentCulture};foreach($m in $Module){$splat.Module=$m;if($t-gt1){$c++;Write-Progress 'Saving MAML' $m -PercentComplete $p -Id $id};$theModule=Get-Module $m;if(-not $theModule){continue};$theModuleRoot=$theModule|Split-Path;$theModuleCultureDir=Join-Path $theModuleRoot $Culture.Name;if(-not (Test-Path $theModuleCultureDir)){$null=New-Item -ItemType Directory -Path $theModuleCultureDir};$theModuleHelpFile=Join-Path $theModuleCultureDir "$m-Help.xml";& $getMAML @splat|Set-Content -Encoding UTF8 -Path $theModuleHelpFile;if($Passthru){Get-Item -Path $theModuleHelpFile}};if($t-gt1){Write-Progress 'Saving MAML' 'Complete' -Completed -Id $id}}} 
#.ExternalHelp HelpOut-Help.xml
function Save-MarkdownHelp{param([Parameter(ParameterSetName='ByModule',ValueFromPipelineByPropertyName)][Alias('Name')][string[]]$Module,[Parameter(ValueFromPipelineByPropertyName)][string]$OutputPath,[Parameter(ValueFromPipelineByPropertyName)][switch]$Wiki,[Parameter(ValueFromPipelineByPropertyName)][Management.Automation.CommandInfo[]]$Command,[Parameter(ValueFromPipelineByPropertyName)][string[]]$ReplaceCommandName,[Parameter(ValueFromPipelineByPropertyName)][string[]]$ReplaceCommandNameWith,[Parameter(ValueFromPipelineByPropertyName)][string[]]$ScriptPath,[Parameter(ValueFromPipelineByPropertyName)][string[]]$ReplaceScriptName,[Parameter(ValueFromPipelineByPropertyName)][string[]]$ReplaceScriptNameWith,[Parameter(ValueFromPipelineByPropertyName)][string[]]$ReplaceLink,[Parameter(ValueFromPipelineByPropertyName)][string[]]$ReplaceLinkWith,[switch]$PassThru,[Parameter(ValueFromPipelineByPropertyName)][string[]]$SectionOrder,[Parameter(ValueFromPipelineByPropertyName)][string[]]$IncludeTopic,[Parameter(ValueFromPipelineByPropertyName)][string[]]$ExcludeTopic,[Parameter(ValueFromPipelineByPropertyName)][string[]]$ExcludeFile,[Parameter(ValueFromPipelineByPropertyName)][string[]]$IncludeExtension,[Parameter(ValueFromPipelineByPropertyName)][switch]$NoValidValueEnumeration,[Parameter(ValueFromPipelineByPropertyName)][Alias('IncludeFrontMatter', 'IncludeHeader')][switch]$IncludeYamlHeader,[ValidateSet('Command','Help','Metadata')][Alias('YamlHeaderInfoType')][string[]]$YamlHeaderInformationType,[Parameter(ValueFromPipelineByPropertyName)][Alias('SkipCommandTypes','ExcludeCommandType','ExcludeCommandTypes')][Management.Automation.CommandTypes[]]$SkipCommandType,[PSObject]$FormatAttribute)begin{$GetMarkdownHelp=if($MyInvocation.MyCommand.ScriptBlock.Module){$MyInvocation.MyCommand.ScriptBlock.Module.ExportedCommands['Get-MarkdownHelp']}else{$ExecutionContext.SessionState.InvokeCommand.GetCommand('Get-MarkdownHelp', 'Function')};$NotExcluded={if(-not $ExcludeFile){return $true};foreach($ex in $ExcludeFile){if($ex-match'^/'-and$ex-match'/$'){if([Regex]::New(
                        $ex -replace '^/' -replace '/$', 'IgnoreCase,IgnorePatternWhitespace'
                    ).Match($_.FullName)){return $false}}else{if($_.FullName-like$ex-or$_.Name-like$ex){return $false}}};return $true};$filesChanged=@()}process{$getMarkdownHelpSplatBase=@{};foreach($param in $psBoundParameters.Keys){if($GetMarkdownHelp.Parameters[$param]){$getMarkdownHelpSplatBase[$param]=$psBoundParameters[$param]}};$c=0;$t=$Module.Count;foreach($m in $Module){if($t-gt1){$c++;$p=$c*100/$t;Write-Progress 'Saving Markdown' $m -PercentComplete $p -Id $id};$theModule=Get-Module $module;if(-not $theModule){continue};$theModuleRoot=$theModule|Split-Path;if(-not $psBoundParameters.OutputPath){$OutputPath=if($Wiki){Split-Path $theModuleRoot|Join-Path -ChildPath "$($theModule.Name).wiki"}else{Join-Path $theModuleRoot "docs"}};if(-not (Test-Path $OutputPath)){$null=New-Item -ItemType Directory -Path $OutputPath};$outputPathName=$OutputPath|Split-Path -Leaf;$ReplaceLink+="^$outputPathName[\\/]";$outputPathItem=Get-Item $OutputPath;if($outputPathItem-isnot[IO.DirectoryInfo]){Write-Error "-OutputPath '$outputPath' must point to a directory";return};foreach($cmd in $theModule.ExportedCommands.Values){if($SkipCommandType-and$SkipCommandType-contains$cmd.CommandType){continue};$docOutputPath=Join-Path $outputPath ($cmd.Name + '.md');$getMarkdownHelpSplat=@{Name="$cmd"}+$getMarkdownHelpSplatBase;if($Wiki){$getMarkdownHelpSplat.Wiki=$Wiki}else{$getMarkdownHelpSplat.GitHubDocRoot="$($outputPath|Split-Path -Leaf)"};$markdownTopic=Get-MarkdownHelp @getMarkdownHelpSplat;$markdownFile=if($markdownTopic.Save){$markdownTopic.Save($docOutputPath)}else{$null};if($markdownFile){$filesChanged+=$markdownFile;if($PassThru){$markdownFile}}};if($Command){foreach($cmd in $Command){$getMarkdownHelpSplat=@{Name=if ($cmd.Source) { "$($cmd.Source)" } else { "$cmd" }}+$getMarkdownHelpSplatBase;$replacedCmdName=if($cmd.DisplayName){$cmd.DisplayName}elseif($cmd.Name-and$cmd.Name.Contains([IO.Path]::DirectorySeparatorChar)){$cmd.Name};@(for($ri = 0;$ri -lt $ReplaceCommandName.Length;$ri++){if($ReplaceCommandNameWith-and$ReplaceCommandNameWith[$ri]){$replacedCmdName=$replacedCmdName-replace$ReplaceCommandName[$ri],$ReplaceCommandNameWith[$ri]}else{$replacedCmdName=$replacedCmdName-replace$ReplaceCommandName[$ri]}});$docOutputPath=Join-Path $outputPath ($replacedCmdName + '.md');$getMarkdownHelpSplat.Rename=$replacedCmdName;if($Wiki){$getMarkdownHelpSplat.Wiki=$Wiki}else{$getMarkdownHelpSplat.GitHubDocRoot="$($outputPath|Split-Path -Leaf)"};$markdownFile=$null;try{$markdownTopic=Get-MarkdownHelp @getMarkdownHelpSplat;$markdownFile=if($markdownTopic.Save){$markdownTopic.Save($docOutputPath)}else{$null}}catch{$ex=$_;Write-Error -Exception $ex.Exception -Message "Could not Get Help for $($cmd.Name): $($ex.Exception.Message)" -TargetObject $getMarkdownHelpSplat};if($markdownFile){$filesChanged+=$markdownFile;if($PassThru-and-not $ReplaceLink){$filesChanged[-1]}}}};if($ScriptPath){Get-ChildItem -Path $theModuleRoot -Recurse|Where-Object {foreach($sp in $ScriptPath){$_.Name-eq$sp-or$_.FullName-eq$sp-or$_.Name-like$sp-or$_.FullName-like$sp-or$($spRegex=$sp-as[regex];$spRegex-and($_.Name-match$spRegex-or$_.FullName-match$spRegex))}}|Get-ChildItem -Recurse|Where-Object Extension -eq '.ps1'|Where-Object $NotExcluded|ForEach-Object {$ps1File=$_;$getMarkdownHelpSplat=@{Name="$($ps1File.FullName)"}+$getMarkdownHelpSplatBase;$replacedFileName=$ps1File.Name;@(for($ri = 0;$ri -lt $ReplaceScriptName.Length;$ri++){if($ReplaceScriptNameWith-and$ReplaceScriptNameWith[$ri]){$replacedFileName=$replacedFileName-replace$ReplaceScriptName[$ri],$ReplaceScriptNameWith[$ri]}else{$replacedFileName=$replacedFileName-replace$ReplaceScriptName[$ri]}});$docOutputPath=Join-Path $outputPath ($replacedFileName + '.md');$relativePath=$ps1File.FullName.Substring("$theModuleRoot".Length).TrimStart('/\').Replace('\','/');$getMarkdownHelpSplat.Rename=$relativePath;if($Wiki){$getMarkdownHelpSplat.Wiki=$Wiki}else{$getMarkdownHelpSplat.GitHubDocRoot="$($outputPath|Split-Path -Leaf)"};$markdownTopic=Get-MarkdownHelp @getMarkdownHelpSplat;$markdownFile=if($markdownTopic.Save){$markdownTopic.Save($docOutputPath)}else{$null};if($markdownFile){$filesChanged+=$markdownFile;if($PassThru-and-not $ReplaceLink){$markdownFile}}}};if($IncludeTopic){$filesArray=@(Get-ChildItem -Path $theModuleRoot -Recurse -File);[array]::reverse($filesArray);$filesArray|Where-Object $NotExcluded|ForEach-Object {$fileInfo=$_;$relativePath=$fileInfo.FullName.Substring("$theModuleRoot".Length)-replace'^[\\/]';if([Regex]::Matches($relativePath, "[\\/]").Count-gt1){return};:NextTopicFile foreach($inc in $IncludeTopic){$matches=$null;if($fileInfo.Name-eq$inc-or$fileInfo.Name-like$inc-or$($incRegex=$inc-as[regex];$incRegex-and$fileInfo.Name-match$incRegex)){foreach($exclude in $ExcludeTopic){if($fileInfo.Name-eq$exclude-or$fileInfo.Name-like$exclude-or$($exclude-as[regex]-and$fileInfo.Name-match$exclude)){continue NextTopicFile}};$replacedName=if($matches){$fileInfo.Name-replace$inc}else{$fileInfo.Name.Substring(0,
                                            $fileInfo.name.Length - $fileInfo.Extension.Length)-replace'\.help$'};if($replacedName-eq"about_$module"){$replacedName='README'};$dest=Join-Path $OutputPath ($replacedName + '.md');if($fileInfo.FullName-ne"$dest"){$filesChanged+=$fileInfo|Copy-Item -Destination $dest -PassThru};if($PassThru-and-not $ReplaceLink){$filesChanged[-1]}}}}};if($IncludeExtension){Get-ChildItem -Path $theModuleRoot -Recurse -File|Where-Object $NotExcluded|ForEach-Object {$fileInfo=$_;foreach($ext in $IncludeExtension){if($fileInfo.Extension-eq$ext-or$fileInfo.Extension-eq".$ext"){$relativePath=$fileInfo.FullName.Substring("$theModuleRoot".Length)-replace'^[\\/]';$outputPathLeaf=$outputPath|Split-Path -Leaf;$dest=Join-Path $OutputPath $relativePath;if($fileInfo.FullName-ne"$dest"-and$relativePath-notlike"$outputPathLeaf$([IO.Path]::DirectorySeparatorChar)*"){$createdFile=New-Item -ItemType File -Path $dest -Force;if(-not $createdFile){Write-Error "Unable to initialize file: '$dest'";break};if($fileInfo.FullName-ne"$dest"){$filesChanged+=$fileInfo|Copy-Item -Destination $dest -PassThru:$PassThru};if($PassThru-and-not $ReplaceLink){$filesChanged[-1]}};break}}}};$MyModule=$MyInvocation.MyCommand.ScriptBlock.Module;$ScriptPattern="$($MyModule.Name)\.$($MyInvocation.MyCommand.Name -replace '\p{P}')\.(?<Name>(?:.|\s){0,}?(?=\z|\.ps1))\.ps1";$commandWildcard="$($MyModule.Name).$($MyInvocation.MyCommand.Name)*";$commandPattern="$($myModule.Name)\.$($MyInvocation.MyCommand.Name -replace '\p{P}')\.(?<Name>(?:.|\s){0,}?(?=\z|\.ps1))";$myExtensions=@(foreach($loadedModule in Get-Module){if($loadedModule-eq$MyModule-or$loadedModule-eq$m-or$loadedModule.Tags-contains$MyModule.Name){foreach($file in Get-ChildItem -Recurse -Filter *.ps1 (
                            Split-Path $loadedModule.Path
                        )){if($file.Name-notmatch$ScriptPattern){continue};$scriptCmd=$ExecutionContext.SessionState.InvokeCommand.GetCommand($file.FullName, 'ExternalScript');$scriptCmd.psobject.Members.Add([psnoteproperty]::new("ExtensionName", $Matches.Name), $true);if($scriptCmd.pstypenames-notcontains"$($myModule.Name).Extension"){$scriptCmd.pstypenames.insert(0, "$($myModule.Name).Extension")};$scriptCmd}}};foreach($cmdFound in $ExecutionContext.SessionState.InvokeCommand.GetCommands(
                    $commandWildcard, 'Function,Alias,Cmdlet', $true
                )-match$commandPattern){$cmdFound.psobject.Members.Add([psnoteproperty]::new("ExtensionName", $Matches.Name), $true);if($cmdFound.pstypenames-notcontains"$($myModule.Name).Extension"){$cmdFound.pstypenames.insert(0, "$($myModule.Name).Extension")};$cmdFound});$extensionOutputs=@(foreach($extension in $myExtensions){$extensionSplat=[Ordered]@{};if($extension.Parameters.Module){$extensionSplat.Module=$theModule};& $extension @extensionSplat});if($extensionOutputs){foreach($extensionOutput in $extensionOutputs){if($extensionOutput-is[IO.FileInfo]){if($extensionOutput.Extension-in'.md','.markdown'-and$ReplaceLink){$filesChanged+=$extensionOutput}elseif($PassThru){$extensionOutput}}}}};if($t-gt1){Write-Progress 'Saving Markdown' 'Complete' -Completed -Id $id}}end{if($PassThru-and$ReplaceLink){$linkFinder=[Regex]::new("
            (?<IsImage>\!)?    # If there is an exclamation point, then it is an image link
            \[                 # Markdown links start with a bracket
            (?<Text>[^\]\r\n]+)
            \]                 # anything until the end bracket is the link text.
            \(                 # The link uri is within parenthesis
            (?<Uri>[^\)\r\n]+)
            \)
            ", 'IgnoreCase,IgnorePatternWhitespace');foreach($file in $filesChanged){if($file.Extension-notin'.md','.markdown'){$file;continue};$fileContent=Get-Content $file.FullName -Raw;$fileContent=$linkFinder.Replace($fileContent, {
                    param($LinkMatch)
                    $linkReplacementNumber = 0

                    $linkUri  = $LinkMatch.Groups["Uri"].ToString()
                    $linkText = $linkMatch.Groups["Text"].ToString()
                    foreach ($linkToReplace in $ReplaceLink) {
                        $replacement = "$($ReplaceLinkWith[$linkReplacementNumber])"
                        $linkUri  = $linkUri  -replace $linkToReplace, $replacement
                        $linkText = $linkText -replace $linkToReplace, $replacement
                    }

                    if ($linkUri -match '\#.+$') {
                        $lowerCaseAnchor = ($matches.0).ToLower()
                        $linkUri = $linkUri -replace '\#.+$', $lowerCaseAnchor
                    }

                    if ($LinkMatch.Groups["IsImage"].Length) {
                        "![$linkText]($linkUri)"
                    } else {
                        "[$linkText]($linkUri)"
                    }
                });Set-Content $file.FullName -Encoding UTF8 -Value $fileContent.Trim();if($PassThru){Get-Item -LiteralPath $file.FullName}}}}}